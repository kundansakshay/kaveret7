<?php
// $Id:

/*
 * User chooser module
 *
 * Just a special form field at the moment, no configuration pages
 * Use it like this:
 * $form['fieldname'] = array(
 *   '#title' => t('Blah blah'),
 *   '#type' => 'user_chooser', // or user_chooser_roles, user_chooser_permissions, user_chooser_callback, user_chooser_preselect
 *   '#args' => array('callback_function') // or the role ids or the permission key or the view and display ids
 *   '#allow_me => boolean  defaults to FALSE //Why would a user want to select themselves?
 *   '#allow_blocked' defaults to FALSE
 *   //etc.
 * );
 * where $callback is 'permission', 'role', or your own callback
 * your own callback should return a list of usernames, with uid keys
 *
 * This module will modify $form_state[values][fieldname] to be the uid, regardless of what was selected
 */

function user_chooser_menu() {
  $items['system/ajax/uchoo'] = array(
    'page callback' => 'uchoo_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'uchoo.inc'
  );
  $items['admin/config/people/user_chooser'] = array(
    'title' => 'User Chooser Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uchoo_config_form'),
    'access arguments' => array('administer modules'),
    'file' => 'uchoo.inc',
    'weight' => 5
  );
  return $items;
}

function user_chooser_hook_info() {
  return array(
    //implementations of this hook return a array of $callback => description
    //where the callback returns a list of account numbers
    'user_chooser_preselect' => array()
  );
}

/*
 * implements hook_element_info
 * the three elements we are offer are essentially the same
 */
function user_chooser_element_info() {
  $fields = array(
    '#input' => TRUE,
    '#process' => array('process_uchoo'),
    '#args' => array(),
    '#theme_wrappers' => array('form_element'),
    '#element_validate' => array('user_chooser_validate'),
    '#multiple' => FALSE,
    '#allow_me' => FALSE,
  );
  foreach (uchoo_types() as $type) {
    $info[$type] = $fields;
  }
  return $info;
}
//these provide ways of carving up the user database by providing a callback and parameters
//each of these could have an access callback and this function could have its own hook
function uchoo_types() {
  return array(
    'user_chooser_callback',
    'user_chooser_preselect',
    'user_chooser_roles',
    'user_chooser_permissions'
  );
}

/*
 * Callback function to process the form element
 * provides all the other metadata for the form element
 */
function process_uchoo($element, &$form_state) {
  form_load_include($form_state, 'inc', 'user_chooser', 'uchoo');
  return _process_uchoo($element, $form_state);
}


/*
 * ajax menu callback
 * the autocomplete a textfield uses get and so you have no access to the form and can't retrieve the triggering element
 * so this is a special callback which expects the path and the $element['name']
 * then it retrieves the triggering element and returns only valid users
 */
function uchoo_autocomplete() {
  $args = func_get_args();
  $string = array_pop($args);
  $element_name = array_pop($args);
  $path = implode('/', $args);
  if ($router_item = menu_get_item($path)) {//borrowed from menu_execute_active handler
    if ($router_item['access']) {
      if ($router_item['include_file']) {
        require_once DRUPAL_ROOT . '/' . $router_item['include_file'];
      }
      $form = call_user_func_array($router_item['page_callback'], $router_item['page_arguments']);
    }
    else $form = MENU_ACCESS_DENIED;
  }
  else $form = MENU_NOT_FOUND;

  $element = $form[$element_name];
  $uids = uchoo_get_valid_uids($element, $string, TRUE);
  die(drupal_json_output(drupal_map_assoc(uchoo_display_all($uids))));
}

/*
 * ACCESS CALLBACKS
 * these two are needed by mutual_credit module
 * but the idea of introducing access control to this module is very interesting
 * that would mean an access callback for every uchoo_type. Thrilling!
 */
function user_chooser_permissions($perms) {
  foreach ((array)$perms as $perm) {
    if (user_access($perm)) return TRUE;
  }
  return FALSE;
}

//access callback
function user_chooser_roles($rid1) {
  //array_intersect is type-sensitive, so we'll do it this way
  $user_roles = $GLOBALS['user']->roles;
  foreach (func_get_args() as $rid) {
    if (isset($user_roles[$rid])) return TRUE;
  }
}
